// Code generated by BobGen mysql v0.28.1. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"hash/maphash"

	"github.com/stephenafamo/bob"
	"github.com/stephenafamo/bob/clause"
	"github.com/stephenafamo/bob/dialect/mysql"
	"github.com/stephenafamo/bob/dialect/mysql/dialect"
)

var TableNames = struct {
	Animals   string
	Breeds    string
	Clinics   string
	Employees string
	Pets      string
	Roles     string
	Services  string
	Timeslots string
	Users     string
}{
	Animals:   "animals",
	Breeds:    "breeds",
	Clinics:   "clinics",
	Employees: "employees",
	Pets:      "pets",
	Roles:     "roles",
	Services:  "services",
	Timeslots: "timeslots",
	Users:     "users",
}

var ColumnNames = struct {
	Animals   animalColumnNames
	Breeds    breedColumnNames
	Clinics   clinicColumnNames
	Employees employeeColumnNames
	Pets      petColumnNames
	Roles     roleColumnNames
	Services  serviceColumnNames
	Timeslots timeslotColumnNames
	Users     userColumnNames
}{
	Animals: animalColumnNames{
		ID:          "id",
		Description: "description",
	},
	Breeds: breedColumnNames{
		ID:          "id",
		AnimalID:    "animal_id",
		Description: "description",
	},
	Clinics: clinicColumnNames{
		ID:         "id",
		UserID:     "user_id",
		Name:       "name",
		Location:   "location",
		BusinessNo: "business_no",
	},
	Employees: employeeColumnNames{
		ID:       "id",
		UserID:   "user_id",
		ClinicID: "clinic_id",
	},
	Pets: petColumnNames{
		ID:        "id",
		Name:      "name",
		Gender:    "gender",
		Birthdate: "birthdate",
		BreedID:   "breed_id",
		OwnerID:   "owner_id",
	},
	Roles: roleColumnNames{
		ID:          "id",
		Description: "description",
	},
	Services: serviceColumnNames{
		ID:          "id",
		ClinicID:    "clinic_id",
		Description: "description",
	},
	Timeslots: timeslotColumnNames{
		ID:        "id",
		VetID:     "vet_id",
		StartTime: "start_time",
	},
	Users: userColumnNames{
		ID:         "id",
		FamilyName: "family_name",
		GivenName:  "given_name",
		Email:      "email",
		Password:   "password",
		RoleID:     "role_id",
	},
}

var (
	SelectWhere = Where[*dialect.SelectQuery]()
	UpdateWhere = Where[*dialect.UpdateQuery]()
	DeleteWhere = Where[*dialect.DeleteQuery]()
)

func Where[Q mysql.Filterable]() struct {
	Animals   animalWhere[Q]
	Breeds    breedWhere[Q]
	Clinics   clinicWhere[Q]
	Employees employeeWhere[Q]
	Pets      petWhere[Q]
	Roles     roleWhere[Q]
	Services  serviceWhere[Q]
	Timeslots timeslotWhere[Q]
	Users     userWhere[Q]
} {
	return struct {
		Animals   animalWhere[Q]
		Breeds    breedWhere[Q]
		Clinics   clinicWhere[Q]
		Employees employeeWhere[Q]
		Pets      petWhere[Q]
		Roles     roleWhere[Q]
		Services  serviceWhere[Q]
		Timeslots timeslotWhere[Q]
		Users     userWhere[Q]
	}{
		Animals:   buildAnimalWhere[Q](AnimalColumns),
		Breeds:    buildBreedWhere[Q](BreedColumns),
		Clinics:   buildClinicWhere[Q](ClinicColumns),
		Employees: buildEmployeeWhere[Q](EmployeeColumns),
		Pets:      buildPetWhere[Q](PetColumns),
		Roles:     buildRoleWhere[Q](RoleColumns),
		Services:  buildServiceWhere[Q](ServiceColumns),
		Timeslots: buildTimeslotWhere[Q](TimeslotColumns),
		Users:     buildUserWhere[Q](UserColumns),
	}
}

var (
	SelectJoins = getJoins[*dialect.SelectQuery]()
	UpdateJoins = getJoins[*dialect.UpdateQuery]()
	DeleteJoins = getJoins[*dialect.DeleteQuery]()
)

type joinSet[Q interface{ aliasedAs(string) Q }] struct {
	InnerJoin Q
	LeftJoin  Q
	RightJoin Q
}

func (j joinSet[Q]) AliasedAs(alias string) joinSet[Q] {
	return joinSet[Q]{
		InnerJoin: j.InnerJoin.aliasedAs(alias),
		LeftJoin:  j.LeftJoin.aliasedAs(alias),
		RightJoin: j.RightJoin.aliasedAs(alias),
	}
}

type joins[Q dialect.Joinable] struct {
	Animals   joinSet[animalJoins[Q]]
	Breeds    joinSet[breedJoins[Q]]
	Clinics   joinSet[clinicJoins[Q]]
	Employees joinSet[employeeJoins[Q]]
	Pets      joinSet[petJoins[Q]]
	Roles     joinSet[roleJoins[Q]]
	Services  joinSet[serviceJoins[Q]]
	Timeslots joinSet[timeslotJoins[Q]]
	Users     joinSet[userJoins[Q]]
}

func buildJoinSet[Q interface{ aliasedAs(string) Q }, C any, F func(C, string) Q](c C, f F) joinSet[Q] {
	return joinSet[Q]{
		InnerJoin: f(c, clause.InnerJoin),
		LeftJoin:  f(c, clause.LeftJoin),
		RightJoin: f(c, clause.RightJoin),
	}
}

func getJoins[Q dialect.Joinable]() joins[Q] {
	return joins[Q]{
		Animals:   buildJoinSet[animalJoins[Q]](AnimalColumns, buildAnimalJoins),
		Breeds:    buildJoinSet[breedJoins[Q]](BreedColumns, buildBreedJoins),
		Clinics:   buildJoinSet[clinicJoins[Q]](ClinicColumns, buildClinicJoins),
		Employees: buildJoinSet[employeeJoins[Q]](EmployeeColumns, buildEmployeeJoins),
		Pets:      buildJoinSet[petJoins[Q]](PetColumns, buildPetJoins),
		Roles:     buildJoinSet[roleJoins[Q]](RoleColumns, buildRoleJoins),
		Services:  buildJoinSet[serviceJoins[Q]](ServiceColumns, buildServiceJoins),
		Timeslots: buildJoinSet[timeslotJoins[Q]](TimeslotColumns, buildTimeslotJoins),
		Users:     buildJoinSet[userJoins[Q]](UserColumns, buildUserJoins),
	}
}

type modAs[Q any, C interface{ AliasedAs(string) C }] struct {
	c C
	f func(C) bob.Mod[Q]
}

func (m modAs[Q, C]) Apply(q Q) {
	m.f(m.c).Apply(q)
}

func (m modAs[Q, C]) AliasedAs(alias string) bob.Mod[Q] {
	m.c = m.c.AliasedAs(alias)
	return m
}

func randInt() int64 {
	out := int64(new(maphash.Hash).Sum64())

	if out < 0 {
		return -out % 10000
	}

	return out % 10000
}
