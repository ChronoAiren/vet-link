// Code generated by BobGen mysql v0.28.1. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"errors"
	"fmt"

	"github.com/aarondl/opt/omit"
	"github.com/stephenafamo/bob"
	"github.com/stephenafamo/bob/dialect/mysql"
	"github.com/stephenafamo/bob/dialect/mysql/dialect"
	"github.com/stephenafamo/bob/dialect/mysql/im"
	"github.com/stephenafamo/bob/dialect/mysql/sm"
	"github.com/stephenafamo/bob/dialect/mysql/um"
	"github.com/stephenafamo/bob/expr"
	"github.com/stephenafamo/bob/mods"
	"github.com/stephenafamo/bob/orm"
)

// User is an object representing the database table.
type User struct {
	ID         uint32 `db:"id,pk,autoincr" `
	FamilyName string `db:"family_name" `
	GivenName  string `db:"given_name" `
	Email      string `db:"email,pk" `
	Password   string `db:"password" `
	RoleID     uint8  `db:"role_id" `

	R userR `db:"-" `
}

// UserSlice is an alias for a slice of pointers to User.
// This should almost always be used instead of []*User.
type UserSlice []*User

// Users contains methods to work with the users table
var Users = mysql.NewTablex[*User, UserSlice, *UserSetter]("users", []string{"id", "email"})

// UsersQuery is a query on the users table
type UsersQuery = *mysql.ViewQuery[*User, UserSlice]

// UsersStmt is a prepared statment on users
type UsersStmt = bob.QueryStmt[*User, UserSlice]

// userR is where relationships are stored.
type userR struct {
	Employees    EmployeeSlice // fk_employees_users_user_id
	OwnerPets    PetSlice      // fk_pets_users_owner_id
	VetTimeslots TimeslotSlice // fk_timeslots_users_vet_id
	Clinics      ClinicSlice   // fk_user_clinics_clinics_user_id
	Role         *Role         // fk_users_roles_role_id
}

// UserSetter is used for insert/upsert/update operations
// All values are optional, and do not have to be set
// Generated columns are not included
type UserSetter struct {
	ID         omit.Val[uint32] `db:"id,pk,autoincr" `
	FamilyName omit.Val[string] `db:"family_name" `
	GivenName  omit.Val[string] `db:"given_name" `
	Email      omit.Val[string] `db:"email,pk" `
	Password   omit.Val[string] `db:"password" `
	RoleID     omit.Val[uint8]  `db:"role_id" `
}

func (s UserSetter) SetColumns() []string {
	vals := make([]string, 0, 6)
	if !s.ID.IsUnset() {
		vals = append(vals, "id")
	}

	if !s.FamilyName.IsUnset() {
		vals = append(vals, "family_name")
	}

	if !s.GivenName.IsUnset() {
		vals = append(vals, "given_name")
	}

	if !s.Email.IsUnset() {
		vals = append(vals, "email")
	}

	if !s.Password.IsUnset() {
		vals = append(vals, "password")
	}

	if !s.RoleID.IsUnset() {
		vals = append(vals, "role_id")
	}

	return vals
}

func (s UserSetter) Overwrite(t *User) {
	if !s.ID.IsUnset() {
		t.ID, _ = s.ID.Get()
	}
	if !s.FamilyName.IsUnset() {
		t.FamilyName, _ = s.FamilyName.Get()
	}
	if !s.GivenName.IsUnset() {
		t.GivenName, _ = s.GivenName.Get()
	}
	if !s.Email.IsUnset() {
		t.Email, _ = s.Email.Get()
	}
	if !s.Password.IsUnset() {
		t.Password, _ = s.Password.Get()
	}
	if !s.RoleID.IsUnset() {
		t.RoleID, _ = s.RoleID.Get()
	}
}

func (s UserSetter) InsertMod() bob.Mod[*dialect.InsertQuery] {
	vals := make([]bob.Expression, 6)
	if s.ID.IsUnset() {
		vals[0] = mysql.Raw("DEFAULT")
	} else {
		vals[0] = mysql.Arg(s.ID)
	}

	if s.FamilyName.IsUnset() {
		vals[1] = mysql.Raw("DEFAULT")
	} else {
		vals[1] = mysql.Arg(s.FamilyName)
	}

	if s.GivenName.IsUnset() {
		vals[2] = mysql.Raw("DEFAULT")
	} else {
		vals[2] = mysql.Arg(s.GivenName)
	}

	if s.Email.IsUnset() {
		vals[3] = mysql.Raw("DEFAULT")
	} else {
		vals[3] = mysql.Arg(s.Email)
	}

	if s.Password.IsUnset() {
		vals[4] = mysql.Raw("DEFAULT")
	} else {
		vals[4] = mysql.Arg(s.Password)
	}

	if s.RoleID.IsUnset() {
		vals[5] = mysql.Raw("DEFAULT")
	} else {
		vals[5] = mysql.Arg(s.RoleID)
	}

	return im.Values(vals...)
}

func (s UserSetter) Apply(q *dialect.UpdateQuery) {
	um.Set(s.Expressions("users")...).Apply(q)
}

func (s UserSetter) Expressions(prefix ...string) []bob.Expression {
	exprs := make([]bob.Expression, 0, 6)

	if !s.ID.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			mysql.Quote(append(prefix, "id")...),
			mysql.Arg(s.ID),
		}})
	}

	if !s.FamilyName.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			mysql.Quote(append(prefix, "family_name")...),
			mysql.Arg(s.FamilyName),
		}})
	}

	if !s.GivenName.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			mysql.Quote(append(prefix, "given_name")...),
			mysql.Arg(s.GivenName),
		}})
	}

	if !s.Email.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			mysql.Quote(append(prefix, "email")...),
			mysql.Arg(s.Email),
		}})
	}

	if !s.Password.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			mysql.Quote(append(prefix, "password")...),
			mysql.Arg(s.Password),
		}})
	}

	if !s.RoleID.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			mysql.Quote(append(prefix, "role_id")...),
			mysql.Arg(s.RoleID),
		}})
	}

	return exprs
}

type userColumnNames struct {
	ID         string
	FamilyName string
	GivenName  string
	Email      string
	Password   string
	RoleID     string
}

var UserColumns = buildUserColumns("users")

type userColumns struct {
	tableAlias string
	ID         mysql.Expression
	FamilyName mysql.Expression
	GivenName  mysql.Expression
	Email      mysql.Expression
	Password   mysql.Expression
	RoleID     mysql.Expression
}

func (c userColumns) Alias() string {
	return c.tableAlias
}

func (userColumns) AliasedAs(alias string) userColumns {
	return buildUserColumns(alias)
}

func buildUserColumns(alias string) userColumns {
	return userColumns{
		tableAlias: alias,
		ID:         mysql.Quote(alias, "id"),
		FamilyName: mysql.Quote(alias, "family_name"),
		GivenName:  mysql.Quote(alias, "given_name"),
		Email:      mysql.Quote(alias, "email"),
		Password:   mysql.Quote(alias, "password"),
		RoleID:     mysql.Quote(alias, "role_id"),
	}
}

type userWhere[Q mysql.Filterable] struct {
	ID         mysql.WhereMod[Q, uint32]
	FamilyName mysql.WhereMod[Q, string]
	GivenName  mysql.WhereMod[Q, string]
	Email      mysql.WhereMod[Q, string]
	Password   mysql.WhereMod[Q, string]
	RoleID     mysql.WhereMod[Q, uint8]
}

func (userWhere[Q]) AliasedAs(alias string) userWhere[Q] {
	return buildUserWhere[Q](buildUserColumns(alias))
}

func buildUserWhere[Q mysql.Filterable](cols userColumns) userWhere[Q] {
	return userWhere[Q]{
		ID:         mysql.Where[Q, uint32](cols.ID),
		FamilyName: mysql.Where[Q, string](cols.FamilyName),
		GivenName:  mysql.Where[Q, string](cols.GivenName),
		Email:      mysql.Where[Q, string](cols.Email),
		Password:   mysql.Where[Q, string](cols.Password),
		RoleID:     mysql.Where[Q, uint8](cols.RoleID),
	}
}

type userJoins[Q dialect.Joinable] struct {
	typ          string
	Employees    func(context.Context) modAs[Q, employeeColumns]
	OwnerPets    func(context.Context) modAs[Q, petColumns]
	VetTimeslots func(context.Context) modAs[Q, timeslotColumns]
	Clinics      func(context.Context) modAs[Q, clinicColumns]
	Role         func(context.Context) modAs[Q, roleColumns]
}

func (j userJoins[Q]) aliasedAs(alias string) userJoins[Q] {
	return buildUserJoins[Q](buildUserColumns(alias), j.typ)
}

func buildUserJoins[Q dialect.Joinable](cols userColumns, typ string) userJoins[Q] {
	return userJoins[Q]{
		typ:          typ,
		Employees:    usersJoinEmployees[Q](cols, typ),
		OwnerPets:    usersJoinOwnerPets[Q](cols, typ),
		VetTimeslots: usersJoinVetTimeslots[Q](cols, typ),
		Clinics:      usersJoinClinics[Q](cols, typ),
		Role:         usersJoinRole[Q](cols, typ),
	}
}

// FindUser retrieves a single record by primary key
// If cols is empty Find will return all columns.
func FindUser(ctx context.Context, exec bob.Executor, IDPK uint32, EmailPK string, cols ...string) (*User, error) {
	if len(cols) == 0 {
		return Users.Query(
			ctx, exec,
			SelectWhere.Users.ID.EQ(IDPK),
			SelectWhere.Users.Email.EQ(EmailPK),
		).One()
	}

	return Users.Query(
		ctx, exec,
		SelectWhere.Users.ID.EQ(IDPK),
		SelectWhere.Users.Email.EQ(EmailPK),
		sm.Columns(Users.Columns().Only(cols...)),
	).One()
}

// UserExists checks the presence of a single record by primary key
func UserExists(ctx context.Context, exec bob.Executor, IDPK uint32, EmailPK string) (bool, error) {
	return Users.Query(
		ctx, exec,
		SelectWhere.Users.ID.EQ(IDPK),
		SelectWhere.Users.Email.EQ(EmailPK),
	).Exists()
}

// PrimaryKeyVals returns the primary key values of the User
func (o *User) PrimaryKeyVals() bob.Expression {
	return mysql.ArgGroup(
		o.ID,
		o.Email,
	)
}

// Update uses an executor to update the User
func (o *User) Update(ctx context.Context, exec bob.Executor, s *UserSetter) error {
	return Users.Update(ctx, exec, s, o)
}

// Delete deletes a single User record with an executor
func (o *User) Delete(ctx context.Context, exec bob.Executor) error {
	return Users.Delete(ctx, exec, o)
}

// Reload refreshes the User using the executor
func (o *User) Reload(ctx context.Context, exec bob.Executor) error {
	o2, err := Users.Query(
		ctx, exec,
		SelectWhere.Users.ID.EQ(o.ID),
		SelectWhere.Users.Email.EQ(o.Email),
	).One()
	if err != nil {
		return err
	}
	o2.R = o.R
	*o = *o2

	return nil
}

func (o UserSlice) UpdateAll(ctx context.Context, exec bob.Executor, vals UserSetter) error {
	return Users.Update(ctx, exec, &vals, o...)
}

func (o UserSlice) DeleteAll(ctx context.Context, exec bob.Executor) error {
	return Users.Delete(ctx, exec, o...)
}

func (o UserSlice) ReloadAll(ctx context.Context, exec bob.Executor) error {
	var mods []bob.Mod[*dialect.SelectQuery]

	IDPK := make([]uint32, len(o))
	EmailPK := make([]string, len(o))

	for i, o := range o {
		IDPK[i] = o.ID
		EmailPK[i] = o.Email
	}

	mods = append(mods,
		SelectWhere.Users.ID.In(IDPK...),
		SelectWhere.Users.Email.In(EmailPK...),
	)

	o2, err := Users.Query(ctx, exec, mods...).All()
	if err != nil {
		return err
	}

	for _, old := range o {
		for _, new := range o2 {
			if new.ID != old.ID {
				continue
			}
			if new.Email != old.Email {
				continue
			}
			new.R = old.R
			*old = *new
			break
		}
	}

	return nil
}

func usersJoinEmployees[Q dialect.Joinable](from userColumns, typ string) func(context.Context) modAs[Q, employeeColumns] {
	return func(ctx context.Context) modAs[Q, employeeColumns] {
		return modAs[Q, employeeColumns]{
			c: EmployeeColumns,
			f: func(to employeeColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, Employees.Name(ctx).As(to.Alias())).On(
						to.UserID.EQ(from.ID),
					))
				}

				return mods
			},
		}
	}
}

func usersJoinOwnerPets[Q dialect.Joinable](from userColumns, typ string) func(context.Context) modAs[Q, petColumns] {
	return func(ctx context.Context) modAs[Q, petColumns] {
		return modAs[Q, petColumns]{
			c: PetColumns,
			f: func(to petColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, Pets.Name(ctx).As(to.Alias())).On(
						to.OwnerID.EQ(from.ID),
					))
				}

				return mods
			},
		}
	}
}

func usersJoinVetTimeslots[Q dialect.Joinable](from userColumns, typ string) func(context.Context) modAs[Q, timeslotColumns] {
	return func(ctx context.Context) modAs[Q, timeslotColumns] {
		return modAs[Q, timeslotColumns]{
			c: TimeslotColumns,
			f: func(to timeslotColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, Timeslots.Name(ctx).As(to.Alias())).On(
						to.VetID.EQ(from.ID),
					))
				}

				return mods
			},
		}
	}
}

func usersJoinClinics[Q dialect.Joinable](from userColumns, typ string) func(context.Context) modAs[Q, clinicColumns] {
	return func(ctx context.Context) modAs[Q, clinicColumns] {
		return modAs[Q, clinicColumns]{
			c: ClinicColumns,
			f: func(to clinicColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, Clinics.Name(ctx).As(to.Alias())).On(
						to.UserID.EQ(from.ID),
					))
				}

				return mods
			},
		}
	}
}

func usersJoinRole[Q dialect.Joinable](from userColumns, typ string) func(context.Context) modAs[Q, roleColumns] {
	return func(ctx context.Context) modAs[Q, roleColumns] {
		return modAs[Q, roleColumns]{
			c: RoleColumns,
			f: func(to roleColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, Roles.Name(ctx).As(to.Alias())).On(
						to.ID.EQ(from.RoleID),
					))
				}

				return mods
			},
		}
	}
}

// Employees starts a query for related objects on employees
func (o *User) Employees(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) EmployeesQuery {
	return Employees.Query(ctx, exec, append(mods,
		sm.Where(EmployeeColumns.UserID.EQ(mysql.Arg(o.ID))),
	)...)
}

func (os UserSlice) Employees(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) EmployeesQuery {
	PKArgs := make([]bob.Expression, len(os))
	for i, o := range os {
		PKArgs[i] = mysql.ArgGroup(o.ID)
	}

	return Employees.Query(ctx, exec, append(mods,
		sm.Where(mysql.Group(EmployeeColumns.UserID).In(PKArgs...)),
	)...)
}

// OwnerPets starts a query for related objects on pets
func (o *User) OwnerPets(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) PetsQuery {
	return Pets.Query(ctx, exec, append(mods,
		sm.Where(PetColumns.OwnerID.EQ(mysql.Arg(o.ID))),
	)...)
}

func (os UserSlice) OwnerPets(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) PetsQuery {
	PKArgs := make([]bob.Expression, len(os))
	for i, o := range os {
		PKArgs[i] = mysql.ArgGroup(o.ID)
	}

	return Pets.Query(ctx, exec, append(mods,
		sm.Where(mysql.Group(PetColumns.OwnerID).In(PKArgs...)),
	)...)
}

// VetTimeslots starts a query for related objects on timeslots
func (o *User) VetTimeslots(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) TimeslotsQuery {
	return Timeslots.Query(ctx, exec, append(mods,
		sm.Where(TimeslotColumns.VetID.EQ(mysql.Arg(o.ID))),
	)...)
}

func (os UserSlice) VetTimeslots(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) TimeslotsQuery {
	PKArgs := make([]bob.Expression, len(os))
	for i, o := range os {
		PKArgs[i] = mysql.ArgGroup(o.ID)
	}

	return Timeslots.Query(ctx, exec, append(mods,
		sm.Where(mysql.Group(TimeslotColumns.VetID).In(PKArgs...)),
	)...)
}

// Clinics starts a query for related objects on clinics
func (o *User) Clinics(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) ClinicsQuery {
	return Clinics.Query(ctx, exec, append(mods,
		sm.Where(ClinicColumns.UserID.EQ(mysql.Arg(o.ID))),
	)...)
}

func (os UserSlice) Clinics(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) ClinicsQuery {
	PKArgs := make([]bob.Expression, len(os))
	for i, o := range os {
		PKArgs[i] = mysql.ArgGroup(o.ID)
	}

	return Clinics.Query(ctx, exec, append(mods,
		sm.Where(mysql.Group(ClinicColumns.UserID).In(PKArgs...)),
	)...)
}

// Role starts a query for related objects on roles
func (o *User) Role(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) RolesQuery {
	return Roles.Query(ctx, exec, append(mods,
		sm.Where(RoleColumns.ID.EQ(mysql.Arg(o.RoleID))),
	)...)
}

func (os UserSlice) Role(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) RolesQuery {
	PKArgs := make([]bob.Expression, len(os))
	for i, o := range os {
		PKArgs[i] = mysql.ArgGroup(o.RoleID)
	}

	return Roles.Query(ctx, exec, append(mods,
		sm.Where(mysql.Group(RoleColumns.ID).In(PKArgs...)),
	)...)
}

func (o *User) Preload(name string, retrieved any) error {
	if o == nil {
		return nil
	}

	switch name {
	case "Employees":
		rels, ok := retrieved.(EmployeeSlice)
		if !ok {
			return fmt.Errorf("user cannot load %T as %q", retrieved, name)
		}

		o.R.Employees = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.User = o
			}
		}
		return nil
	case "OwnerPets":
		rels, ok := retrieved.(PetSlice)
		if !ok {
			return fmt.Errorf("user cannot load %T as %q", retrieved, name)
		}

		o.R.OwnerPets = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.OwnerUser = o
			}
		}
		return nil
	case "VetTimeslots":
		rels, ok := retrieved.(TimeslotSlice)
		if !ok {
			return fmt.Errorf("user cannot load %T as %q", retrieved, name)
		}

		o.R.VetTimeslots = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.VetUser = o
			}
		}
		return nil
	case "Clinics":
		rels, ok := retrieved.(ClinicSlice)
		if !ok {
			return fmt.Errorf("user cannot load %T as %q", retrieved, name)
		}

		o.R.Clinics = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.User = o
			}
		}
		return nil
	case "Role":
		rel, ok := retrieved.(*Role)
		if !ok {
			return fmt.Errorf("user cannot load %T as %q", retrieved, name)
		}

		o.R.Role = rel

		if rel != nil {
			rel.R.Users = UserSlice{o}
		}
		return nil
	default:
		return fmt.Errorf("user has no relationship %q", name)
	}
}

func ThenLoadUserEmployees(queryMods ...bob.Mod[*dialect.SelectQuery]) mysql.Loader {
	return mysql.Loader(func(ctx context.Context, exec bob.Executor, retrieved any) error {
		loader, isLoader := retrieved.(interface {
			LoadUserEmployees(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
		})
		if !isLoader {
			return fmt.Errorf("object %T cannot load UserEmployees", retrieved)
		}

		err := loader.LoadUserEmployees(ctx, exec, queryMods...)

		// Don't cause an issue due to missing relationships
		if errors.Is(err, sql.ErrNoRows) {
			return nil
		}

		return err
	})
}

// LoadUserEmployees loads the user's Employees into the .R struct
func (o *User) LoadUserEmployees(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.Employees = nil

	related, err := o.Employees(ctx, exec, mods...).All()
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.User = o
	}

	o.R.Employees = related
	return nil
}

// LoadUserEmployees loads the user's Employees into the .R struct
func (os UserSlice) LoadUserEmployees(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	employees, err := os.Employees(ctx, exec, mods...).All()
	if err != nil {
		return err
	}

	for _, o := range os {
		o.R.Employees = nil
	}

	for _, o := range os {
		for _, rel := range employees {
			if o.ID != rel.UserID {
				continue
			}

			rel.R.User = o

			o.R.Employees = append(o.R.Employees, rel)
		}
	}

	return nil
}

func ThenLoadUserOwnerPets(queryMods ...bob.Mod[*dialect.SelectQuery]) mysql.Loader {
	return mysql.Loader(func(ctx context.Context, exec bob.Executor, retrieved any) error {
		loader, isLoader := retrieved.(interface {
			LoadUserOwnerPets(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
		})
		if !isLoader {
			return fmt.Errorf("object %T cannot load UserOwnerPets", retrieved)
		}

		err := loader.LoadUserOwnerPets(ctx, exec, queryMods...)

		// Don't cause an issue due to missing relationships
		if errors.Is(err, sql.ErrNoRows) {
			return nil
		}

		return err
	})
}

// LoadUserOwnerPets loads the user's OwnerPets into the .R struct
func (o *User) LoadUserOwnerPets(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.OwnerPets = nil

	related, err := o.OwnerPets(ctx, exec, mods...).All()
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.OwnerUser = o
	}

	o.R.OwnerPets = related
	return nil
}

// LoadUserOwnerPets loads the user's OwnerPets into the .R struct
func (os UserSlice) LoadUserOwnerPets(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	pets, err := os.OwnerPets(ctx, exec, mods...).All()
	if err != nil {
		return err
	}

	for _, o := range os {
		o.R.OwnerPets = nil
	}

	for _, o := range os {
		for _, rel := range pets {
			if o.ID != rel.OwnerID {
				continue
			}

			rel.R.OwnerUser = o

			o.R.OwnerPets = append(o.R.OwnerPets, rel)
		}
	}

	return nil
}

func ThenLoadUserVetTimeslots(queryMods ...bob.Mod[*dialect.SelectQuery]) mysql.Loader {
	return mysql.Loader(func(ctx context.Context, exec bob.Executor, retrieved any) error {
		loader, isLoader := retrieved.(interface {
			LoadUserVetTimeslots(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
		})
		if !isLoader {
			return fmt.Errorf("object %T cannot load UserVetTimeslots", retrieved)
		}

		err := loader.LoadUserVetTimeslots(ctx, exec, queryMods...)

		// Don't cause an issue due to missing relationships
		if errors.Is(err, sql.ErrNoRows) {
			return nil
		}

		return err
	})
}

// LoadUserVetTimeslots loads the user's VetTimeslots into the .R struct
func (o *User) LoadUserVetTimeslots(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.VetTimeslots = nil

	related, err := o.VetTimeslots(ctx, exec, mods...).All()
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.VetUser = o
	}

	o.R.VetTimeslots = related
	return nil
}

// LoadUserVetTimeslots loads the user's VetTimeslots into the .R struct
func (os UserSlice) LoadUserVetTimeslots(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	timeslots, err := os.VetTimeslots(ctx, exec, mods...).All()
	if err != nil {
		return err
	}

	for _, o := range os {
		o.R.VetTimeslots = nil
	}

	for _, o := range os {
		for _, rel := range timeslots {
			if o.ID != rel.VetID {
				continue
			}

			rel.R.VetUser = o

			o.R.VetTimeslots = append(o.R.VetTimeslots, rel)
		}
	}

	return nil
}

func ThenLoadUserClinics(queryMods ...bob.Mod[*dialect.SelectQuery]) mysql.Loader {
	return mysql.Loader(func(ctx context.Context, exec bob.Executor, retrieved any) error {
		loader, isLoader := retrieved.(interface {
			LoadUserClinics(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
		})
		if !isLoader {
			return fmt.Errorf("object %T cannot load UserClinics", retrieved)
		}

		err := loader.LoadUserClinics(ctx, exec, queryMods...)

		// Don't cause an issue due to missing relationships
		if errors.Is(err, sql.ErrNoRows) {
			return nil
		}

		return err
	})
}

// LoadUserClinics loads the user's Clinics into the .R struct
func (o *User) LoadUserClinics(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.Clinics = nil

	related, err := o.Clinics(ctx, exec, mods...).All()
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.User = o
	}

	o.R.Clinics = related
	return nil
}

// LoadUserClinics loads the user's Clinics into the .R struct
func (os UserSlice) LoadUserClinics(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	clinics, err := os.Clinics(ctx, exec, mods...).All()
	if err != nil {
		return err
	}

	for _, o := range os {
		o.R.Clinics = nil
	}

	for _, o := range os {
		for _, rel := range clinics {
			if o.ID != rel.UserID {
				continue
			}

			rel.R.User = o

			o.R.Clinics = append(o.R.Clinics, rel)
		}
	}

	return nil
}

func PreloadUserRole(opts ...mysql.PreloadOption) mysql.Preloader {
	return mysql.Preload[*Role, RoleSlice](orm.Relationship{
		Name: "Role",
		Sides: []orm.RelSide{
			{
				From: "users",
				To:   TableNames.Roles,
				ToExpr: func(ctx context.Context) bob.Expression {
					return Roles.Name(ctx)
				},
				FromColumns: []string{
					ColumnNames.Users.RoleID,
				},
				ToColumns: []string{
					ColumnNames.Roles.ID,
				},
			},
		},
	}, Roles.Columns().Names(), opts...)
}

func ThenLoadUserRole(queryMods ...bob.Mod[*dialect.SelectQuery]) mysql.Loader {
	return mysql.Loader(func(ctx context.Context, exec bob.Executor, retrieved any) error {
		loader, isLoader := retrieved.(interface {
			LoadUserRole(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
		})
		if !isLoader {
			return fmt.Errorf("object %T cannot load UserRole", retrieved)
		}

		err := loader.LoadUserRole(ctx, exec, queryMods...)

		// Don't cause an issue due to missing relationships
		if errors.Is(err, sql.ErrNoRows) {
			return nil
		}

		return err
	})
}

// LoadUserRole loads the user's Role into the .R struct
func (o *User) LoadUserRole(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.Role = nil

	related, err := o.Role(ctx, exec, mods...).One()
	if err != nil {
		return err
	}

	related.R.Users = UserSlice{o}

	o.R.Role = related
	return nil
}

// LoadUserRole loads the user's Role into the .R struct
func (os UserSlice) LoadUserRole(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	roles, err := os.Role(ctx, exec, mods...).All()
	if err != nil {
		return err
	}

	for _, o := range os {
		for _, rel := range roles {
			if o.RoleID != rel.ID {
				continue
			}

			rel.R.Users = append(rel.R.Users, o)

			o.R.Role = rel
			break
		}
	}

	return nil
}

func insertUserEmployees0(ctx context.Context, exec bob.Executor, employees1 []*EmployeeSetter, user0 *User) (EmployeeSlice, error) {
	for i := range employees1 {
		employees1[i].UserID = omit.From(user0.ID)
	}

	ret, err := Employees.InsertMany(ctx, exec, employees1...)
	if err != nil {
		return ret, fmt.Errorf("insertUserEmployees0: %w", err)
	}

	return ret, nil
}

func attachUserEmployees0(ctx context.Context, exec bob.Executor, count int, employees1 EmployeeSlice, user0 *User) (EmployeeSlice, error) {
	setter := &EmployeeSetter{
		UserID: omit.From(user0.ID),
	}

	err := Employees.Update(ctx, exec, setter, employees1...)
	if err != nil {
		return nil, fmt.Errorf("attachUserEmployees0: %w", err)
	}

	return employees1, nil
}

func (user0 *User) InsertEmployees(ctx context.Context, exec bob.Executor, related ...*EmployeeSetter) error {
	if len(related) == 0 {
		return nil
	}

	employees1, err := insertUserEmployees0(ctx, exec, related, user0)
	if err != nil {
		return err
	}

	user0.R.Employees = append(user0.R.Employees, employees1...)

	for _, rel := range employees1 {
		rel.R.User = user0
	}
	return nil
}

func (user0 *User) AttachEmployees(ctx context.Context, exec bob.Executor, related ...*Employee) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	employees1 := EmployeeSlice(related)

	_, err = attachUserEmployees0(ctx, exec, len(related), employees1, user0)
	if err != nil {
		return err
	}

	user0.R.Employees = append(user0.R.Employees, employees1...)

	for _, rel := range related {
		rel.R.User = user0
	}

	return nil
}

func insertUserOwnerPets0(ctx context.Context, exec bob.Executor, pets1 []*PetSetter, user0 *User) (PetSlice, error) {
	for i := range pets1 {
		pets1[i].OwnerID = omit.From(user0.ID)
	}

	ret, err := Pets.InsertMany(ctx, exec, pets1...)
	if err != nil {
		return ret, fmt.Errorf("insertUserOwnerPets0: %w", err)
	}

	return ret, nil
}

func attachUserOwnerPets0(ctx context.Context, exec bob.Executor, count int, pets1 PetSlice, user0 *User) (PetSlice, error) {
	setter := &PetSetter{
		OwnerID: omit.From(user0.ID),
	}

	err := Pets.Update(ctx, exec, setter, pets1...)
	if err != nil {
		return nil, fmt.Errorf("attachUserOwnerPets0: %w", err)
	}

	return pets1, nil
}

func (user0 *User) InsertOwnerPets(ctx context.Context, exec bob.Executor, related ...*PetSetter) error {
	if len(related) == 0 {
		return nil
	}

	pets1, err := insertUserOwnerPets0(ctx, exec, related, user0)
	if err != nil {
		return err
	}

	user0.R.OwnerPets = append(user0.R.OwnerPets, pets1...)

	for _, rel := range pets1 {
		rel.R.OwnerUser = user0
	}
	return nil
}

func (user0 *User) AttachOwnerPets(ctx context.Context, exec bob.Executor, related ...*Pet) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	pets1 := PetSlice(related)

	_, err = attachUserOwnerPets0(ctx, exec, len(related), pets1, user0)
	if err != nil {
		return err
	}

	user0.R.OwnerPets = append(user0.R.OwnerPets, pets1...)

	for _, rel := range related {
		rel.R.OwnerUser = user0
	}

	return nil
}

func insertUserVetTimeslots0(ctx context.Context, exec bob.Executor, timeslots1 []*TimeslotSetter, user0 *User) (TimeslotSlice, error) {
	for i := range timeslots1 {
		timeslots1[i].VetID = omit.From(user0.ID)
	}

	ret, err := Timeslots.InsertMany(ctx, exec, timeslots1...)
	if err != nil {
		return ret, fmt.Errorf("insertUserVetTimeslots0: %w", err)
	}

	return ret, nil
}

func attachUserVetTimeslots0(ctx context.Context, exec bob.Executor, count int, timeslots1 TimeslotSlice, user0 *User) (TimeslotSlice, error) {
	setter := &TimeslotSetter{
		VetID: omit.From(user0.ID),
	}

	err := Timeslots.Update(ctx, exec, setter, timeslots1...)
	if err != nil {
		return nil, fmt.Errorf("attachUserVetTimeslots0: %w", err)
	}

	return timeslots1, nil
}

func (user0 *User) InsertVetTimeslots(ctx context.Context, exec bob.Executor, related ...*TimeslotSetter) error {
	if len(related) == 0 {
		return nil
	}

	timeslots1, err := insertUserVetTimeslots0(ctx, exec, related, user0)
	if err != nil {
		return err
	}

	user0.R.VetTimeslots = append(user0.R.VetTimeslots, timeslots1...)

	for _, rel := range timeslots1 {
		rel.R.VetUser = user0
	}
	return nil
}

func (user0 *User) AttachVetTimeslots(ctx context.Context, exec bob.Executor, related ...*Timeslot) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	timeslots1 := TimeslotSlice(related)

	_, err = attachUserVetTimeslots0(ctx, exec, len(related), timeslots1, user0)
	if err != nil {
		return err
	}

	user0.R.VetTimeslots = append(user0.R.VetTimeslots, timeslots1...)

	for _, rel := range related {
		rel.R.VetUser = user0
	}

	return nil
}

func insertUserClinics0(ctx context.Context, exec bob.Executor, clinics1 []*ClinicSetter, user0 *User) (ClinicSlice, error) {
	for i := range clinics1 {
		clinics1[i].UserID = omit.From(user0.ID)
	}

	ret, err := Clinics.InsertMany(ctx, exec, clinics1...)
	if err != nil {
		return ret, fmt.Errorf("insertUserClinics0: %w", err)
	}

	return ret, nil
}

func attachUserClinics0(ctx context.Context, exec bob.Executor, count int, clinics1 ClinicSlice, user0 *User) (ClinicSlice, error) {
	setter := &ClinicSetter{
		UserID: omit.From(user0.ID),
	}

	err := Clinics.Update(ctx, exec, setter, clinics1...)
	if err != nil {
		return nil, fmt.Errorf("attachUserClinics0: %w", err)
	}

	return clinics1, nil
}

func (user0 *User) InsertClinics(ctx context.Context, exec bob.Executor, related ...*ClinicSetter) error {
	if len(related) == 0 {
		return nil
	}

	clinics1, err := insertUserClinics0(ctx, exec, related, user0)
	if err != nil {
		return err
	}

	user0.R.Clinics = append(user0.R.Clinics, clinics1...)

	for _, rel := range clinics1 {
		rel.R.User = user0
	}
	return nil
}

func (user0 *User) AttachClinics(ctx context.Context, exec bob.Executor, related ...*Clinic) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	clinics1 := ClinicSlice(related)

	_, err = attachUserClinics0(ctx, exec, len(related), clinics1, user0)
	if err != nil {
		return err
	}

	user0.R.Clinics = append(user0.R.Clinics, clinics1...)

	for _, rel := range related {
		rel.R.User = user0
	}

	return nil
}

func attachUserRole0(ctx context.Context, exec bob.Executor, count int, user0 *User, role1 *Role) (*User, error) {
	setter := &UserSetter{
		RoleID: omit.From(role1.ID),
	}

	err := Users.Update(ctx, exec, setter, user0)
	if err != nil {
		return nil, fmt.Errorf("attachUserRole0: %w", err)
	}

	return user0, nil
}

func (user0 *User) InsertRole(ctx context.Context, exec bob.Executor, related *RoleSetter) error {
	role1, err := Roles.Insert(ctx, exec, related)
	if err != nil {
		return fmt.Errorf("inserting related objects: %w", err)
	}

	_, err = attachUserRole0(ctx, exec, 1, user0, role1)
	if err != nil {
		return err
	}

	user0.R.Role = role1

	role1.R.Users = append(role1.R.Users, user0)

	return nil
}

func (user0 *User) AttachRole(ctx context.Context, exec bob.Executor, role1 *Role) error {
	var err error

	_, err = attachUserRole0(ctx, exec, 1, user0, role1)
	if err != nil {
		return err
	}

	user0.R.Role = role1

	role1.R.Users = append(role1.R.Users, user0)

	return nil
}
